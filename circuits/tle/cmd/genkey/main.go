package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/groth16"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"

	"vte-tlock/circuits/tle"
)

// This tool generates and saves the PK and VK for embedding for the TLE circuit
// Run: go run circuits/tle/cmd/genkey/main.go
func main() {
	fmt.Println("Generating TLE circuit keys (trusted setup)...")

	// Compile circuit
	// TLE circuit is heavy (~50k constraints expected)
	var c tle.Circuit
	ccs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &c)
	if err != nil {
		fmt.Printf("Circuit compilation failed: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Circuit compiled with %d constraints\n", ccs.GetNbConstraints())

	// Groth16 trusted setup (generates randomness)
	fmt.Println("Running Groth16 trusted setup...")
	pk, vk, err := groth16.Setup(ccs)
	if err != nil {
		fmt.Printf("Setup failed: %v\n", err)
		os.Exit(1)
	}

	// Serialize VK
	var vkBuf bytes.Buffer
	_, err = vk.WriteTo(&vkBuf)
	if err != nil {
		fmt.Printf("VK serialization failed: %v\n", err)
		os.Exit(1)
	}
	vkBytes := vkBuf.Bytes()

	// Serialize PK
	var pkBuf bytes.Buffer
	_, err = pk.WriteTo(&pkBuf)
	if err != nil {
		fmt.Printf("PK serialization failed: %v\n", err)
		os.Exit(1)
	}
	pkBytes := pkBuf.Bytes()

	// Compute VK hash for identification
	vkHash := sha256.Sum256(vkBytes)

	fmt.Printf("VK size: %d bytes\n", len(vkBytes))
	fmt.Printf("PK size: %d bytes\n", len(pkBytes))
	fmt.Printf("VK hash (circuit_id): %s\n", hex.EncodeToString(vkHash[:]))

	// Save VK to binary file
	vkPath := "circuits/tle/vk.bin"
	err = os.WriteFile(vkPath, vkBytes, 0644)
	if err != nil {
		fmt.Printf("Failed to write VK: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("VK saved to: %s\n", vkPath)

	// Save PK to binary file
	pkPath := "circuits/tle/pk.bin"
	err = os.WriteFile(pkPath, pkBytes, 0644)
	if err != nil {
		fmt.Printf("Failed to write PK: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("PK saved to: %s\n", pkPath)

	// Create Go embed file for both keys
	goContent := fmt.Sprintf(`package tle

// AUTO-GENERATED - DO NOT EDIT
// Generated by: go run circuits/tle/cmd/genkey/main.go
// This file contains the embedded proving and verifying keys from trusted setup
// VK Hash: %s

import _ "embed"

//go:embed vk.bin
var EmbeddedVK []byte

//go:embed pk.bin
var EmbeddedPK []byte

// CircuitID is the SHA256 hash of the VK (first 16 bytes hex)
const CircuitID = "%s"

// FullVKHash is the complete SHA256 hash of the VK
const FullVKHash = "%s"
`, hex.EncodeToString(vkHash[:16]), hex.EncodeToString(vkHash[:16]), hex.EncodeToString(vkHash[:]))

	embedPath := "circuits/tle/vk_embed.go"
	err = os.WriteFile(embedPath, []byte(goContent), 0644)
	if err != nil {
		fmt.Printf("Failed to write embed file: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Go embed file saved to: %s\n", embedPath)

	fmt.Println("\nâœ… Done! TLE Keys are now ready for embedding.")
	fmt.Println("Use tle.EmbeddedPK for proving and tle.EmbeddedVK for verification.")
}
